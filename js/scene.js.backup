import { GAME_CONFIG, RENDER_CONFIG } from './config.js';

class Scene {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = null;
        this.renderer = null;
        this.ground = null;
        this.player = null;
        this.isRunning = false;
        this.speed = 0;
        this.targetSpeed = 0;
        this.terrainSystem = {
            grounds: [],
            decorations: [],
            segmentLength: GAME_CONFIG.terrainSegmentLength,
            segmentWidth: GAME_CONFIG.terrainWidth,
            activeSegments: GAME_CONFIG.activeTerrainSegments,
            decorationsPerSegment: GAME_CONFIG.decorationsPerSegment,
            maxDecorationsPool: GAME_CONFIG.maxDecorationsPool,
            lastGeneratedZ: 0
        };
        this.decorationPool = [];
        this.fps = 0;
        this.frameCount = 0;
        this.fpsUpdateInterval = 1000; 
        this.lastFpsUpdate = performance.now();
    }

    async init() {
        this.initScene();
        this.initCamera();
        this.initRenderer();
        this.initLights();
        this.initTerrain();
        window.addEventListener('resize', this.onWindowResize.bind(this));
    }

    initScene() {
        this.scene.background = new THREE.Color(0x87ceeb);
    }

    initCamera() {
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 2, -5);
        this.camera.lookAt(0, 0, 5);
    }

    initRenderer() {
        this.renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('gameCanvas'),
            antialias: false,
            powerPreference: 'high-performance',
            precision: 'lowp'
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); 
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.BasicShadowMap; 
        
        this.renderer.dispose = function() {
            this.forceContextLoss();
            this.domElement = null;
            this.context = null;
        };
    }

    initLights() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 50, 0);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        this.scene.add(directionalLight);
    }

    initTerrain() {
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x228B22,
            roughness: 0.8,
            metalness: 0.2
        });

        // ‰ΩøÁî®ÂéüÂßãÁöÑÂ∞ñÂΩ¢Ê†ëÊú®Âá†‰Ωï‰Ωì
        const treeGeometry = new THREE.CylinderGeometry(0, 1, 4, 4);
        const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
        const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

        // ÂàõÂª∫ÂàùÂßãÊ†ëÊú®Ê±?        for (let i = 0; i < this.terrainSystem.maxDecorationsPool; i++) {
            const tree = new THREE.Group();
            
            const crown = new THREE.Mesh(treeGeometry, treeMaterial);
            crown.position.y = 3;
            crown.castShadow = true;
            tree.add(crown);
            
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // ÈöèÊú∫Áº©ÊîæÊ†ëÊú®Ôºå‰ΩøÂÖ∂Â§ßÂ∞èÂ§öÊ†∑Âåñ
            const scale = 0.8 + Math.random() * 0.4;
            tree.scale.set(scale, scale, scale);
            
            tree.visible = false;
            this.scene.add(tree);
            this.decorationPool.push(tree);
        }

        for (let i = 0; i < this.terrainSystem.activeSegments; i++) {
            const groundGeometry = new THREE.PlaneGeometry(
                this.terrainSystem.segmentWidth,
                this.terrainSystem.segmentLength
            );
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            groundMesh.position.z = i * this.terrainSystem.segmentLength;
            this.scene.add(groundMesh);
            this.terrainSystem.grounds.push(groundMesh);
            this.terrainSystem.lastGeneratedZ = (i + 1) * this.terrainSystem.segmentLength;

            // ‰∏∫ÊØè‰∏™ÂàùÂßãÂú∞ÂΩ¢ÊÆµÊ∑ªÂä†Êõ¥Â§öÁöÑÊ†ëÊú?            this.addDecorationsToSegment(i);
        }
    }

    addDecorationsToSegment(segmentIndex) {
        const newSegmentDecorations = Math.floor(this.terrainSystem.decorationsPerSegment * 2);
        for (let i = 0; i < newSegmentDecorations && this.decorationPool.length > 0; i++) {
            const decoration = this.decorationPool.pop();
            decoration.visible = true;

            const x = (Math.random() - 0.5) * (this.terrainSystem.segmentWidth - 10);
            const z = segmentIndex * this.terrainSystem.segmentLength + Math.random() * this.terrainSystem.segmentLength;
            decoration.position.set(x, 0, z);

            decoration.rotation.y = Math.random() * Math.PI * 2;
            const scale = 0.5 + Math.random() * 0.5;
            decoration.scale.set(scale, scale, scale);

            this.terrainSystem.decorations.push(decoration);
        }
    }

    updateSpeed(speed) {
        this.speed = speed;
        
        const cameraHeight = 2 + Math.sin(performance.now() * 0.005) * (speed * 0.06); 
        const cameraX = Math.cos(performance.now() * 0.003) * (speed * 0.04); 
        
        this.camera.position.y = THREE.MathUtils.lerp(this.camera.position.y, cameraHeight, 0.15); 
        this.camera.position.x = THREE.MathUtils.lerp(this.camera.position.x, cameraX, 0.15); 
        this.camera.position.z += speed * 0.025; 
        
        const lookAtPoint = new THREE.Vector3(
            0,
            this.camera.position.y + 0.5,
            this.camera.position.z + 12 
        );
        this.camera.lookAt(lookAtPoint);

        this.updateTerrain();
    }

    updateTerrain() {
        const cameraZ = this.camera.position.z;
        
        if (cameraZ + this.terrainSystem.segmentLength > this.terrainSystem.lastGeneratedZ - this.terrainSystem.segmentLength) {
            const oldGround = this.terrainSystem.grounds.shift();
            if (oldGround) {
                oldGround.position.z = this.terrainSystem.lastGeneratedZ;
                this.terrainSystem.grounds.push(oldGround);
                
                this.terrainSystem.lastGeneratedZ += this.terrainSystem.segmentLength;
            }
            
            const decorationsToRecycle = this.terrainSystem.decorations.filter(decoration => {
                return decoration.position.z < cameraZ - this.terrainSystem.segmentLength * 4;
            });
            
            decorationsToRecycle.forEach(decoration => {
                decoration.visible = false;
                this.decorationPool.push(decoration);
            });
            
            this.terrainSystem.decorations = this.terrainSystem.decorations.filter(
                decoration => !decorationsToRecycle.includes(decoration)
            );
            
            const newSegmentStart = this.terrainSystem.lastGeneratedZ - this.terrainSystem.segmentLength;
            const newSegmentEnd = this.terrainSystem.lastGeneratedZ;
            
            const speedFactor = Math.max(1.0, Math.min(2.0, this.speed / 5));
            const decorationsToAdd = Math.max(15, Math.floor(this.terrainSystem.decorationsPerSegment * speedFactor));
            
            this.ensureDecorationPool();
            
            for (let i = 0; i < decorationsToAdd; i++) {
                if (this.decorationPool.length === 0) {
                    this.createNewDecoration();
                }
                
                const decoration = this.decorationPool.pop();
                if (!decoration) continue;
                
                const z = newSegmentStart + (Math.random() * this.terrainSystem.segmentLength);
                const x = (Math.random() - 0.5) * this.terrainSystem.segmentWidth * 0.9;
                
                decoration.position.set(x, 0, z);

                decoration.rotation.y = Math.random() * Math.PI * 2;
                decoration.visible = true;
                
                const distanceToCamera = Math.abs(z - cameraZ);
                if (distanceToCamera > 150) {
                    decoration.scale.setScalar(0.5);
                } else if (distanceToCamera > 100) {
                    decoration.scale.setScalar(0.8);
                } else {
                    decoration.scale.setScalar(1.0);
                }
                
                if (!this.scene.children.includes(decoration)) {
                    this.scene.add(decoration);
                }
                
                this.terrainSystem.decorations.push(decoration);
            }
        }
        
        this.terrainSystem.decorations.forEach(decoration => {
            const distanceToCamera = Math.abs(decoration.position.z - cameraZ);
            let targetScale = 1.0;
            
            if (distanceToCamera > 150) {
                targetScale = 0.5;
            } else if (distanceToCamera > 100) {
                targetScale = 0.8;
            }
            
            decoration.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
            
            if (!decoration.visible) {
                decoration.visible = true;
            }
        });
    }
    
    ensureDecorationPool() {
        // Â¢ûÂä†ÊúÄÂ∞èÊ±†Â§ßÂ∞èÔºåÁ°Æ‰øùÊúâË∂≥Â§üÁöÑÊ†ëÊú®ÂèØ‰ª•‰ΩøÁî?        const minPoolSize = Math.max(30, this.terrainSystem.decorationsPerSegment);
        
        // Â¶ÇÊûúË£ÖÈ•∞Áâ©Ê±†Â§™Â∞èÔºåÂàõÂª∫Êõ¥Â§öÁöÑË£ÖÈ•∞Áâ?        while (this.decorationPool.length < minPoolSize && 
               this.decorationPool.length + this.terrainSystem.decorations.length < this.terrainSystem.maxDecorationsPool) {
            this.createNewDecoration();
        }
        
        // Â¶ÇÊûúÊÄªË£ÖÈ•∞Áâ©Êï∞Èáè‰∏çË∂≥Ôºå‰πüÂàõÂª∫Êõ¥Â§öË£ÖÈ•∞Áâ?        const totalDecorations = this.decorationPool.length + this.terrainSystem.decorations.length;
        if (totalDecorations < this.terrainSystem.maxDecorationsPool * 0.8) {
            const decorationsToCreate = Math.min(
                20,
                this.terrainSystem.maxDecorationsPool - totalDecorations
            );
            
            for (let i = 0; i < decorationsToCreate; i++) {
                this.createNewDecoration();
            }
        }
    }
    
    createNewDecoration() {
        // Âè™ÂàõÂª∫Ê†ëÊú®Á±ªÂûãÔºå‰ΩÜÊúâ‰∏çÂêåÂΩ¢Áä∂
        const treeTypes = [
            // Â∞ñÂΩ¢Ê†?            { 
                geometry: new THREE.ConeGeometry(0, 1, 4), 
                color: 0x228B22, 
                scale: 1.5,
                height: 3.5
            },
            // Êõ¥Â∞ñÁöÑÊ†ë
            { 
                geometry: new THREE.ConeGeometry(0, 1.2, 6), 
                color: 0x32CD32, 
                scale: 1.3,
                height: 4
            },
            // ÂúÜÂΩ¢Ê†ëÂÜ†
            { 
                geometry: new THREE.SphereGeometry(0.8, 8, 8), 
                color: 0x006400, 
                scale: 1.3,
                height: 3
            },
            // Ê§≠ÂúÜÂΩ¢Ê†ëÂÜ?            {
                geometry: new THREE.SphereGeometry(1.2, 8, 8),
                color: 0x228B22,
                scale: 1.2,
                height: 3.2
            },
            // ÂÆΩÂ∞ñÂΩ¢Ê†ë
            {
                geometry: new THREE.ConeGeometry(0, 1.5, 8),
                color: 0x006400,
                scale: 1.4,
                height: 3.8
            }
        ];
        
        const typeIndex = Math.floor(Math.random() * treeTypes.length);
        const type = treeTypes[typeIndex];
        
        // ÂàõÂª∫Ê†ëÊú®
        const tree = new THREE.Group();
        
        // ÂàõÂª∫Ê†ëÂÜ†
        const crownMaterial = new THREE.MeshLambertMaterial({ color: type.color });
        const crown = new THREE.Mesh(type.geometry, crownMaterial);
        crown.position.y = type.height;
        crown.castShadow = true;
        tree.add(crown);
        
        // ÂàõÂª∫Ê†ëÂπ≤
        const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, type.height * 0.7, 8);
        const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = type.height * 0.35;
        trunk.castShadow = true;
        tree.add(trunk);
        
        tree.scale.setScalar(type.scale);
        tree.visible = false;
        tree.castShadow = true;
        tree.receiveShadow = true;
        
        this.decorationPool.push(tree);
    }

    setRunningState(isRunning, targetSpeed) {
        this.isRunning = isRunning;
        this.targetSpeed = Math.min(targetSpeed, GAME_CONFIG.maxSpeed);
    }

    onWindowResize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
    }

    optimizePerformance() {
        const { dynamicQuality, lodDistances } = RENDER_CONFIG;
        
        // Âä®ÊÄÅË¥®ÈáèË∞ÉÊï?        if (dynamicQuality && this.fps < 30) {
            // Â¶ÇÊûúFPS‰Ωé‰∫é30ÔºåÈÄêÊ≠•Èôç‰ΩéË¥®Èáè
            if (this.renderer.getPixelRatio() > 1) {
                this.renderer.setPixelRatio(this.renderer.getPixelRatio() - 0.25);
            }
            
            // ÂáèÂ∞ëÂèØËßÅË£ÖÈ•∞Áâ©Ôºå‰ΩÜ‰øùÊåÅÊõ¥Â§öÁöÑÊ†ëÊú®ÂèØËßÅ
            const visibleDecorations = this.terrainSystem.decorations.filter(d => d.visible).length;
            // Âè™ÊúâÂΩìÂèØËßÅË£ÖÈ•∞Áâ©Êï∞ÈáèË∂ÖËøá100Êó∂ÊâçËÄÉËôëÈöêËóè‰∏Ä‰∫õÔºàÊèêÈ´òÈòàÂÄºÔºâ
            if (visibleDecorations > 100) {
                // Âè™ÈöêËóèÈùûÂ∏∏ËøúÂ§ÑÁöÑË£ÖÈ•∞Áâ?                const farDecorations = this.terrainSystem.decorations
                    .filter(d => d.visible && Math.abs(d.position.z - this.camera.position.z) > lodDistances.far * 1.5) // Â¢ûÂä†Ë∑ùÁ¶ªÈòàÂÄ?                    .slice(0, Math.floor(visibleDecorations * 0.1)); // Âè™ÈöêËó?0%ÁöÑËøúÂ§ÑË£ÖÈ•∞Áâ©ÔºàÂáèÂ∞ëÊØî‰æãÔºâ
                
                farDecorations.forEach(d => {
                    d.visible = false;
                    this.decorationPool.push(d);
                });
                
                this.terrainSystem.decorations = this.terrainSystem.decorations
                    .filter(d => !farDecorations.includes(d));
            }
        }
    }

    render() {
        if (!this.renderer) return;
        
        // ËÆ°ÁÆóFPS
        const now = performance.now();
        this.frameCount++;
        
        if (now - this.lastFpsUpdate >= this.fpsUpdateInterval) {
            this.fps = Math.round((this.frameCount * 1000) / (now - this.lastFpsUpdate));
            this.lastFpsUpdate = now;
            this.frameCount = 0;
            
            // ÊØèÁßíÊâßË°å‰∏ÄÊ¨°ÊÄßËÉΩ‰ºòÂåñ
            this.optimizePerformance();
        }
        
        const directionalLight = this.scene.children.find(child => child instanceof THREE.DirectionalLight);
        if (directionalLight) {
            directionalLight.position.set(
                this.camera.position.x + 50,
                50,
                this.camera.position.z
            );
            directionalLight.target.position.set(
                this.camera.position.x,
                0,
                this.camera.position.z
            );
            directionalLight.target.updateMatrixWorld();
        }
        
        this.renderer.render(this.scene, this.camera);
    }
}

export const sceneManager = new Scene();
// Á°Æ‰øùÊâÄÊúâÊ†ëÊú®ÂßãÁªàÂèØËßÅÁöÑËæÖÂä©ÊñπÊ≥ï
ensureTreesVisible() { this.terrainSystem.decorations.forEach(decoration => { decoration.visible = true; }); }
